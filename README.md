# SortAlgorithm-程序设计与算法大作业
## 常规版本 
### 一、实现这五种排序并分析  
#### 1. 选择排序   
基本思想                              
&emsp;&emsp;每一趟排序待排序序列中选出最小的元素，(先假设第一个元素是最小的，遍历后面的元素，不断记录更小的元素下标，即可得到一趟遍历中最小元素)然后与该未排序序列的第一个元素交换位置，确定该元素的位置，如此重复直到所有元素排序完成。  
       
  时间复杂度     
 &emsp;&emsp; 一趟排序的比较次数是0(n)，重复n-1趟，所以时间复杂度是0(n^2)。

主要代码    
![在这里插入图片描述](https://img-blog.csdnimg.cn/579d308a035d4e10abce73b24dc28aa9.png#pic_center)<br /><br />


#### 2. 归并排序   
 基本思想        
&emsp;&emsp; 先将最初长度为n的待排序序列从中间划分成两个子序列，再递归划分左右两个子序列，形成 n个长度为1的有序子序列 。再将相邻的两个子序列两两合并，形成有序序列，如此重复最后得到长度为n的有序序列。     
&emsp;&emsp; 一趟合并的过程：借助一个临时数组，比较待合并的左右两个序列的第一个元素大小，将较小的赋值给临时数组，直到两个子序列的元素都完成合并。     
 
 时间复杂度  
&emsp;&emsp; 归并排序的时间复杂度为归并的趟数与每一趟归并的时间的复杂度的乘积。子算法merge合并的时间复杂度为0(n),趟数为log₂n ,故算法复杂度为0(nlogn)。

主要代码     
![在这里插入图片描述](https://img-blog.csdnimg.cn/7eb5fcae5cda416082e6d526ab92d516.png#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/8d5e50dd4d65415e91085787d771e476.png#pic_center)<br /><br />


#### 3. 快速排序   
基本思想
&emsp;&emsp;  从当前待排序序列中选择最后一个元素作为主元，把小于等于主元的所有元素移动到主元前边，大于等于基准元素的所有元素都移动到主元后边，确定主元的最终位置，然后分别对前后两个序列递归上述过程，直到所有元素完成排序。

时间复杂度  
&emsp;&emsp; 快排一趟排序确定一个元素的位置，时间复杂度为O(n)，在平均情况下递归趟数为log₂n ，算法复杂度为0(nlogn)。在序列已经有序的情况下，需要重复n-1趟才能确定所有元素的位置，时间复杂度为0(n^2)。


主要代码    
![在这里插入图片描述](https://img-blog.csdnimg.cn/85a84d0cc28842aab4fc49992c3d8c34.png#pic_center)<br /><br />


#### 4. 希尔排序   
基本思想    
&emsp;&emsp;首先确定元素间隔数gap，然后将所有位置相隔gap的元素视为一个子序列，对各个子序列进行排序；然后缩小间隔数，并重新对形成的子序列进行排序，直到gap = 1。
&emsp;&emsp;这里初始gap设为n/2，每次缩小一半。子序列内部采用冒泡排序。

时间复杂度
&emsp;&emsp;希尔排序的排序趟数为log₂n；当子序列分的越多时，子序列内的元素就越少，元素比较交换次数就越少，而当子序列的个数减少时，整个序列接近有序，子序列的元素虽然变多但元素之间的比较交换次数没有随之变多。所以一般情况下，认为希尔排序的时间复杂度在0(nlogn)与0(n^2)之间。

主要代码   
![在这里插入图片描述](https://img-blog.csdnimg.cn/0274afa78ac847528ca3bd0b371955d6.png#pic_center)<br /><br />

#### 5. 基数排序   
基本思想       
&emsp;&emsp;先将待排序序列按个位数排好，然后按顺序复制回原数组；再按十位排序好，按顺序复制回原数组；依次类推，按百位、千位....完成排序，排序的趟数就是最大数的位数。   
&emsp;&emsp;具体实现需要借助桶，九个桶分别对应的是0~9十个数字。桶里装的不是元素本身，而是桶编号对应的元素个数， 累加，最后桶的值代表元素的顺序。         

 时间复杂度        
 &emsp;&emsp;排序的趟数是最大数的位数d,而每趟排序的时间复杂度的为O(n),所以基数排序时间复杂度为O(dn)。   
     
 主要代码   
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/ecbfcd2c78374c7891b83f2721d7563e.png#pic_center)<br /><br /><br />

  
 
### 二、分析其在不同规模的输入下单机性能变化情况  
#### 1.  实现过程  
 &emsp;&emsp;生成不同长度的随机数组，计时 ，比较这五种排序算法随机实验10次的平均运行时间。      
 &emsp;&emsp;以选择排序为例： ![在这里插入图片描述](https://img-blog.csdnimg.cn/ce3324e912014308926b2bbb4a7db7e4.png#pic_center)

#### 2. 结果分析
实验结果  
如下表所示，单位ms
| 输入规模 | n=1000 | n=10000 |n=100000 |n=1000000
 | :----: | :----: | :----: | :----: |:----: |
| 选择排序 | 1.20 | 98.00 |10170.20 | -- |
| 归并排序 |0.00 | 1.10 | 14.50 | 165.10 |
| 快速排序 | 0.00 | 1.00 | 11.70 | 178.40 |
| 希尔排序 | 0.10 | 4.50 | 82.00 | 1394.40 |
| 基数排序 | 0.00 | 0.70 | 9.30 | 88.20 |


性能分析 
&emsp;&emsp;从实验结果来看，这五种排序耗时从小到大为：基数排序<归并排序和快速排序（一个数量级）<希尔排序<选择排序   
&emsp;&emsp;(1)  快速排序和归并排序在不同输入规模下耗时相近，属于同一个数量级。
&emsp;&emsp;(2)  希尔排序的耗时 在归并/快排和选择排序之间，但更接近归并/快排，所以时间复杂度更接近0(nlogn)。  
&emsp;&emsp;(3)在输入规模在1000及以下时，五种排序算法用时差别不明显；而输入规模每增大10倍，选择排序耗时增大近似100倍，所以随着输入规模的增大，时间差异越发明显，在输入规模达到百万数量级时，很难运行出结果。

总结
| 排序算法 | 平均时间 |稳定性 |备注
 | :----: | :----: | :----: | :----: 
| 选择排序 | O(n^2) | 不稳定 |n小时较好|
| 归并排序 |O(nlogn)  | 稳定 |n大时较好 | 
| 快速排序 | O(nlogn) | 不稳定 | n大、元素较无序时较好 | 
| 希尔排序 |O(nlogn)  | 不稳定 | 更接近O(nlogn)
| 基数排序 | O(dn) | 稳定 | d 是位数 | 

